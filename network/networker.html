<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gatlin Networker</title>
    <script type="text/javascript" src="eventemitter2.min.js"></script>
    <script type="text/javascript" src="roslib.min.js"></script>
    <script type="text/javascript" src="sizeof.js"></script>
    <style></style>
</head>
<body>
<div class="container">
    <h1>Gatlin Networker</h1>
    <h3 id="data_rate"></h3>
    <table id="mapping_rate_table" cellpadding="10">
        <tr>
            <th>Sub</th>
            <th>Pub</th>
            <th>In Topic</th>
            <th>Out Topic</th>
            <th>Bandwith (MB/sec)</th>
            <th>Rate (msg/sec)</th>
        </tr>
    </table>
</div>

<script>

    var total_size = 0;
    var mapping_bytes = {};
    var mapping_count = {};
    var bandwith_cells = {};
    var rate_cells = {};

    var data_rate_output = document.getElementById('data_rate');
    var mapping_rate_table = document.getElementById('mapping_rate_table');

    var update_rate = 2;
    var ms = 1000 / update_rate;
    function getDataRate() {
        var rate = total_size / ms;
        for(mapping_id in mapping_bytes) {
            var topic_bandwith = mapping_bytes[mapping_id] / ms;
            var topic_rate = mapping_count[mapping_id] / (ms/1000);
            mapping_bytes[mapping_id] = 0;
            mapping_count[mapping_id] = 0;
            bandwith_cells[mapping_id].innerHTML = topic_bandwith.toFixed(2);
            rate_cells[mapping_id].innerHTML = topic_rate.toFixed(2);
        }
        total_size = 0;
        data_rate_output.innerHTML = "Total Bandwith: "+rate.toFixed(3)+" MB/sec";
        return rate;
    }

    var dataRatePub = setInterval(getDataRate, ms);

    var msg_cache = {};
    function msg_size_cached(message, type) {
        if( msg_cache[type] === undefined ) {
            msg_cache[type] = sizeof(message);
        }

        return msg_cache[type];
    }

    function update_topic_size(mapping_id, size) {
        mapping_bytes[mapping_id] += size;
        mapping_count[mapping_id] += 1;
        total_size += size;
    }

    function createROS(name, ip, port) {

        var ros = new ROSLIB.Ros({
            url : "ws://"+ip+":"+port
        });

        ros.on('connection', function() {
            console.log('Connected to '+name+' websocket server.');
        });

        ros.on('error', function(error) {
            console.log('Error connecting to '+name+' websocket server: ', error);
        });

        ros.on('close', function() {
            console.log('Connection to '+name+' websocket server closed.');
        });

        ros.name = name;

        return ros;
    }

    function forwardTopic(sub_ros, pub_ros, topic, type) { remapTopic(sub_ros, pub_ros, topic, topic, type); }
    function remapTopic(sub_ros, pub_ros, sub_topic_name, pub_topic_name, type) {
        var mapping_id = sub_ros.name+sub_topic_name+"->"+pub_ros.name+pub_topic_name;
        mapping_bytes[mapping_id] = 0;
        mapping_count[mapping_id] = 0;
        var row = mapping_rate_table.insertRow();
        row.insertCell().innerHTML = sub_ros.name;
        row.insertCell().innerHTML = pub_ros.name;
        row.insertCell().innerHTML = sub_topic_name;
        row.insertCell().innerHTML = pub_topic_name;
        bandwith_cells[mapping_id] = row.insertCell();
        rate_cells[mapping_id] = row.insertCell();

            var pub_topic = new ROSLIB.Topic({
            ros : pub_ros,
            name : pub_topic_name,
            messageType : type
        });
        
        var sub_topic = new ROSLIB.Topic({
            ros : sub_ros,
            name : sub_topic_name,
            messageType : type
        });

        sub_topic.subscribe(function(message) {
            // console.log('Received message on ' + sub_topic.name + ': ' + message.data);
            pub_topic.publish(message);
            // console.log('Sent message on ' + pub_topic.name + ': ' + message.data);

            // determine size of message
            var size = msg_size_cached(message, sub_topic.messageType);
            update_topic_size(mapping_id, size);
        });
    }

    function forwardService(client_ros, server_ros, name, req_type, resp_type) {
        forwardTopic(client_ros, server_ros, name+'/request', req_type);        
        forwardTopic(server_ros, client_ros, name+'/response', resp_type);        
    }

    // test_ros = createROS("test", "192.168.1.100", 9090);
    // test2_ros = createROS("test2", "127.0.0.1", 9090);
    // remapTopic(test_ros, test2_ros, '/test_string0', '/test_string1', 'std_msgs/String');
    // remapTopic(test_ros, test2_ros, '/test_string2', '/test_string3', 'std_msgs/String');
    // remapTopic(test_ros, test2_ros, '/cmd_vel0', '/cmd_vel1', 'geometry_msgs/Twist');
    // note: maximum topic frequency is 100 Hz ??

    // var hub_ip = "192.168.1.103";
    // hub_ros = createROS("hub", hub_ip, 9090);
    // var youbot_ip = "192.168.1.100";
    // youbot_ros = createROS("youbot", youbot_ip, 9090);
    // remapTopic(hub_ros, youbot_ros, '/cmd_vel_mux/input/teleop', '/cmd_vel', 'geometry_msgs/Twist');
    // var turtlebot_ip = "192.168.1.100";
    // turtlebot_ros = createROS("turtlebot", turtlebot_ip, 9090);
    // forwardTopic(hub_ros, turtlebot_ros, '/cmd_vel_mux/input/teleop', 'geometry_msgs/Twist');

    var hub_ip = "192.168.4.83";
    var gatlin_ip = "192.168.4.82";
    var baxter_ip = "128.84.103.242";

    hub_ros = createROS("hub", hub_ip, 9090);
    gatlin_ros = createROS("gatlin", gatlin_ip, 9090);
    baxter_ros = createROS("baxter", baxter_ip, 9090);

    // gatlin -> unity
    forwardTopic(gatlin_ros, hub_ros, '/gatlin_mott_response', 'std_msgs/String');
    forwardTopic(gatlin_ros, hub_ros, '/tool_tip_link_in_base_link', 'geometry_msgs/PoseStamped');
    forwardTopic(gatlin_ros, hub_ros, '/octomap_array', 'std_msgs/UInt16MultiArray');
    forwardTopic(gatlin_ros, hub_ros, '/map', 'nav_msgs/OccupancyGrid');
    forwardTopic(gatlin_ros, hub_ros, '/robot_pose', 'geometry_msgs/PoseStamped');
    forwardTopic(gatlin_ros, hub_ros, '/camera_link_in_base_link', 'geometry_msgs/PoseStamped');
    forwardTopic(gatlin_ros, hub_ros, '/map_pose', 'geometry_msgs/PoseStamped');
    forwardTopic(gatlin_ros, hub_ros, '/gatlin/objectlist', 'gatlin/ObjectList');

    // unity -> gatlin
    forwardTopic(hub_ros, gatlin_ros, '/gatlin_cmd', 'std_msgs/Int32');
    forwardTopic(hub_ros, gatlin_ros, '/gatlin_res', 'std_msgs/Float32');
    forwardTopic(hub_ros, gatlin_ros, '/cmd_vel_mux/input/teleop', 'geometry_msgs/Twist');
    forwardTopic(hub_ros, gatlin_ros, '/target_pos', 'geometry_msgs/Vector3');
    forwardTopic(hub_ros, gatlin_ros, '/head_pos', 'geometry_msgs/Vector3');
    forwardTopic(hub_ros, gatlin_ros, '/move/gripper', 'std_msgs/Float32');
    forwardTopic(hub_ros, gatlin_ros, '/move_to_goal', 'geometry_msgs/PoseStamped');
    forwardTopic(hub_ros, gatlin_ros, '/arm_target_pose', 'geometry_msgs/PoseStamped');
    forwardTopic(hub_ros, gatlin_ros, '/gatlin_mott', 'gatlin/Mott');
    forwardTopic(hub_ros, gatlin_ros, '/gatlin_mott_command', 'std_msgs/String');

    // TODO:
    // test the gatlin hub link with unity client connected to lab computer ip

</script>
</body>
</html>
