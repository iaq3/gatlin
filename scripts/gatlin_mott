#!/usr/bin/env python
import time
from threading import Thread
import rospy, sys, tf
from math import *
from geometry_msgs.msg import *
from tf.transformations import *
from tf import *
from copy import deepcopy
from turtle_sim.msg import Velocity
	

def PointDistance (p1, p2) :
		return ((p1.x-p2.x)** 2 + (p1.y - p2.y)** 2 + (p1.z - p2.z)**2)**.5


class Mott_Thread(Thread) :
	def __init__(self, gm, on, tn):
		Thread.__init__(self)
		self.gatlin_mott = gm
		self.object_name = on
		self.target_name = tn
		self.rate = rospy.rate(30)

	def run(self):

		#gmap move base to object
		self.gatlin_mott.publishResponse("Gmap base to "+self.object_name)
		self.gatlin_mott.gmapBaseTo(self.gatlin_mott.object_pose)
		while gatlin_mott.distanceToObject() > .6 :
			time.sleep(.03)
		#stop gmap base
		self.gatlin_mott.cancelgmapBaseTo()

		#servo base to object
		self.gatlin_mott.publishResponse("Servo base to "+self.object_name)
		while gatlin_mott.distanceToObject() > .3 :
			#TODO
			time.sleep(.03)

		time.sleep(1)

		object_pos_backup = self.gatlin_mott.object_pose.position

		holding_object = false
		while not holding_object :
			self.gatlin_mott.publishResponse("Attempting to grab "+self.object_name)
			#open gripper
			self.gatlin_mott.sendGripCommand(1)

			object_pos_backup = self.gatlin_mott.object_pose.position

			#arm to object
			self.gatlin_matt.arm_pose_pub.publish(self.gatlin_mott.object_pose)

			#grab
			self.gatlin_mott.sendGripCommand(.3)

			#arm up
			self.gatlin_mott.sendResetArm()

			time.sleep(1)

			if ball not there : #TODO
				holding_object = true
		
		self.gatlin_mott.publishResponse("Grabbed "+self.object_name)

		#gmap move base to target
		self.gatlin_mott.publishResponse("Gmap base to "+self.target_name)
		self.gatlin_mott.gmapBaseTo(self.gatlin_mott.target_pose)
		while gatlin_mott.distanceToTarget() > .6 :
			time.sleep(.03)
		#stop gmap base
		self.gatlin_mott.cancelgmapBaseTo()

		#servo base to target
		self.gatlin_mott.publishResponse("Servo base to "+self.target_name)
		while gatlin_mott.distanceToTarget() > .3 :
			#TODO
			time.sleep(.03)

		#move arm to target TODO

		#release
		self.gatlin_mott.sendGripCommand(1)

		self.gatlin_mott.publishResponse("finished")
		self.gatlin_mott.working = false


class gatlin_mott:

	def MottCallback(self, data) :
		self.object_sub.unregister()
		self.target_sub.unregister()

		self.object_sub = rospy.Subscriber(data.object_topic, Pose, objectPoseCallback, queue_size = 1)
		self.target_sub = rospy.Subscriber(data.target_topic, Pose, targetPoseCallback, queue_size = 1)
		
		if (!self.working) :
			self.working = True
			Mott_Thread(self).start()


	def robotPoseCallback(self, data) :
		self.robot_pose = data

	def objectPoseCallback(self, data) :
		self.object_pose = data

	def targetPoseCallback(self, data) :
		self.target_pose = data

	def cancelgmapBaseTo(self) :
		self.gatlin_cmd_pub.publish(9)

	def sendGripCommand(self, val) :
		msg = Point()
		msg.x = val
		msg.y = -1
		msg.z = -1
		self.gripper_pub.publish(msg)

	def sendResetArm(self) :
		msg = Point()
		msg.x = -2
		msg.y = -2
		msg.z = -2
		self.gripper_pub.publish(msg)

	def gmapBaseTo(self, p) :
		p.orientation = self.robot_pose.orientation
		self.gmap_base_pub.publish(p)

	def publishResponse(self, statement) : 
		self.response_pub.publish(statement)

	def distanceToObject(self) :
		return PointDistance(self.robot_pose.position, self.object_pose.position)

	def distanceToTarget(self) :
		return PointDistance(self.robot_pose.position, self.target_pose.position)

	def __init__(self, target):
		rospy.init_node('gatlin_mott')

		self.robot_pose = Pose()
		self.object_pose = Pose()
		self.target_pose = Pose()
		self.working = False;

		self.response_pub = rospy.Publisher("/gatlin_mott_response", String)
		self.gmap_base_pub = rospy.Publisher("/move_to_goal", Pose)
		self.gripper_pub = rospy.Publisher("/target_pos", Point)
		self.gatlin_cmd_pub = rospy.Publisher("/gatlin_cmd", int)
		self.arm_pose_pub = rospy.Publisher("/arm_target_pose", Pose)


		rospy.Subscriber("/gatlin_mott", Mott, MottCallback, queue_size = 1)
		rospy.Subscriber("/robot_pose", Pose, robotPoseCallback, queue_size =1)
		self.object_sub = rospy.Subscriber("/green_kinect0_pose", Pose, objectPoseCallback, queue_size = 1)
		self.target_sub = rospy.Subscriber("/green_kinect0_pose", Pose, targetPoseCallback, queue_size = 1)


if __name__ == "__main__":
	gatlin_mott()